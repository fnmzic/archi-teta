# Основные операции MongoDB
**Aggregation**

позволяет комбинировать и преобразовывать данные из разных документов, агрегировать результаты и получать более гибкие и специализированные выводы.
*Пример*
Допустим, у нас есть коллекция "orders" с документами, представляющими заказы в интернет-магазине. Каждый документ содержит информацию о клиенте, дате заказа, сумме покупки и другие поля.
Мы можем использовать Aggregation, чтобы выполнить запрос, который вернет суммарную выручку за каждый месяц. Вот пример такого запроса:
db.orders.aggregate([
  {
    $group: {
      _id: { $month: "$date" },
      totalRevenue: { $sum: "$amount" }
    }
  },
  {
    $sort: { _id: 1 }
  }
])

**Text Search**
позволяет эффективно находить документы, содержащие заданные ключевые слова или фразы.
*Пример*
Для выполнения текстового поиска мы должны сначала создать индекс текстового поиска на поле "content":
db.articles.createIndex({ content: "text" })
После создания индекса мы можем выполнять запросы на текстовый поиск с использованием оператора $text:
db.articles.find({ $text: { $search: "MongoDB" } })
Результатом будет набор документов, где каждый документ соответствует критериям текстового поиска.

**MapReduce**
используется для агрегации данных и выполнения вычислений на наборе документов. Она состоит из двух этапов: map (отображение) и reduce (сведение).
Этап map выполняет преобразование данных, применяя определенную функцию (map function) к каждому документу коллекции. Результатом этого этапа является набор промежуточных ключ-значение пар.
Этап reduce объединяет и сводит промежуточные значения с одинаковыми ключами, используя заданную функцию (reduce function). Результатом этого этапа является конечный набор сводных данных.
*Пример*
Для выполнения операции Map-Reduce мы должны задать функции map и reduce:
var mapFunction = function() {
    emit(this.product, this.quantity);
};

var reduceFunction = function(key, values) {
    return Array.sum(values);
};
Затем мы можем выполнить операцию Map-Reduce на коллекции "orders":
db.orders.mapReduce(
    mapFunction,
    reduceFunction,
    { out: "product_totals" }
);
После выполнения операции Map-Reduce мы можем получить результаты:
Результатом будет набор документов в коллекции "product_totals", где каждый документ содержит тип продукта и соответствующее общее количество.

**Geospatial queries**
позволяют выполнять поиск и анализ данных, основываясь на географической информации.
В MongoDB для работы с геопространственными данными используется формат GeoJSON, который представляет геометрические объекты, такие как точки, линии и полигоны, в структуре JSON.
*Основные операторы*

Оператор `$near` позволяет найти ближайшие объекты к заданной       географической точке.
Оператор `$geoWithin` позволяет найти    объекты,    полностью находящиеся внутри заданной географической    области.
Оператор    `$geoIntersects` позволяет найти объекты, которые    пересекаются с    заданной географической областью.

**Transactions**
Транзакции (Transactions) в MongoDB позволяют выполнять набор операций как единое атомарное действие. Транзакции обеспечивают консистентность данных и гарантируют, что либо все операции в транзакции будут успешно выполнены, либо ни одна из них не будет применена.
*Пример*
session.startTransaction(); // Начало транзакции

try {
  // Выполнение операций в рамках транзакции
  const collection1 = session.getDatabase("mydb").getCollection("collection1");
  const collection2 = session.getDatabase("mydb").getCollection("collection2");

  collection1.insertOne({ _id: 1, name: "Document 1" });
  collection2.updateOne({ _id: 2 }, { $set: { name: "Updated Document 2" } });

  session.commitTransaction(); // Фиксация транзакции
} catch (error) {
  print(`Transaction aborted. Error: ${error}`);
  session.abortTransaction(); // Отмена транзакции
} finally {
  session.endSession(); // Завершение сеанса
}
В приведенном примере мы начинаем транзакцию с помощью `session.startTransaction()`, выполняем операции над коллекциями `collection1` и `collection2`, а затем фиксируем транзакцию с помощью `session.commitTransaction()`. Если происходит ошибка, мы отменяем транзакцию с помощью `session.abortTransaction()`.
